{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Circulatory Autogen","text":"<p>Circulatory Autogen aims to automate the process of combining CellML modules into a system model, then doing parameter identification to calibrate to clinical data. </p> <p>Common use cases include generating coupled biochemical cell models, generating neuron to cardiomyocyte models, generating patient specific 0D blood flow networks and more.</p>"},{"location":"#why-circulatory-autogen","title":"Why Circulatory Autogen","text":"<p>Circulatory Autogen provides the following benefits.</p> <ul> <li> <p>Allows module reusability in system models:</p> <p>This software allows reusability and easy coupling of CellML modules. A wide range of openly available modules can be accessed and easily coupled to whatever modules you want to develop. Therefore, instead of having one huge model that will rarely be reused, you can easily integrate modules to create a system model and the modules can be used by others. </p> </li> <li> <p>Provides the ability to calibrate model parameters to clinical or experimental data:</p> <p>This software supports parameter identification algorithms which you can use to calibrate the model parameters to clinical or experimental data.</p> </li> <li> <p>Code generation</p> <p>By generating models in CellML, the user can then re-generate their model in whatever language they want (C++, Fortran, Matlab) with libcellml. This allows for easy coupling with other types of models (PDE), C generation for embedded systems, and much more. </p> </li> <li> <p>Open Source</p> <p>Circulatory Autogen is completely open source. Unlike Software like Simulink, you will never need to pay to use Circulatory Autogen and you can continue using it outside of academia. This further promotes reproducible science by encouraging anyone to use and check the modules or models that are created.</p> </li> </ul>"},{"location":"#what-circulatory-autogen-can-do","title":"What Circulatory Autogen can do","text":"<p>Circulatory Autogen provides the following two main functionalities.</p> <ol> <li> <p>Model Autogeneration</p> <p>This generates a system model by combining CellML modules in a user-defined network/arrangement. For more information, refer section Model Generation and Simulation.</p> </li> <li> <p>Parameter Identification</p> <p>This allows calibrating model parameters to data. See section Parameter Identification for more information.</p> </li> </ol>"},{"location":"create-model/","title":"Creating a new model","text":"<p>This software is designed so the user can easily make their own modules and couple them with existing modules. The steps are as follows.</p> <ol> <li> <p>Either choose an existing <code>{module_category}_modules.cellml</code> file to write your module, or if it is a new category of module, create a <code>{module_category}_modules.cellml</code> file in <code>src/generators/resources/</code>.</p> </li> <li> <p>Put you cellml model into the <code>{module_category}_modules.cellml</code> file.</p> </li> <li> <p>Create a corresponding module configuration entry into <code>module_config.json</code>. These module declarations detail the variables that can be accessed, the constants that must be defined and the available ports of the module.</p> </li> <li> <p>Include your new module into the vessel array file.</p> <p>Note</p> <p>Modules that are connected as each others inputs and outputs will be coupled together with any ports with corresponding name. </p> <p>For an example, if VesselOne has an entrance 'vessel_port' and VesselTwo has an entrance 'vessel_port', they will be coupled with the variables declared in their corresponding 'vessel_port'. You must be careful when making a new module, that the modules it couples to only has matching port types for the ones that are necessary for coupling.</p> </li> </ol> <p>Following sections include more details on creating the above required files.</p>"},{"location":"create-model/#creating-vessel_array-and-parameter-files","title":"Creating vessel_array and parameter files","text":"<p>This section discusses creating a vessel array and parameters files to build a new desired model.</p> <p>One standard vessel array file contains five important columns as elaborated in the table below. </p> <ul> <li>vessel_name is the name of a common organ or part of the cardiovascular system.</li> <li>BC_type is the type of the boundary condition for the vessel's input and output.</li> <li>vessel_type can be defined as the desired module which exists in the module_config.json file. However, the readily usable vessel_types are possible as shown in the table. </li> <li>inp_vessel is the input of each part.</li> <li>out_vessel is the output of each part.</li> </ul> Column name Possible inputs vessel_name User defined, but it is better to use common names like 'heart', 'pvn', 'par', etc. BC_type 'vv', 'vp', 'pv', 'pp', 'pp_wCont', 'pp_wLocal', 'nn' (linked to BC_type in the module_config.json file) vessel_type 'heart', 'arterial', 'arterial_simple', 'venous', 'terminal', 'split_junction', 'merge_junction', '2in2out_junction', 'gas_transport_simple', 'pulomonary_GE', 'baroreceptor', 'chemoreceptor' (linked to vessel_type in the module_config.json file) inp_vessels name of the input vessels, which is one (or more) of the vessel_name entries in the other rows out_vessel name of the output vessels, which is one (or more) of the vessel_name entries in other rows <p>Below figure is an example of a vessel_array file.</p> <p></p> <p>Every row of the vessel array file represents a specific part or module in the defined system. Therefore, each module needs several parameters for modeling and generating a CellML file.</p> <p>These parameters should be inserted in the parameters file: <code>[resources_dir]/[file_prefix]_parameters.csv</code>.</p> <p>This file has the structure as shown below.</p> Column Name Description variable_name Parameter name units Unit in the defined units in CellML's unit file value Value of parameter data_reference Reference of the parameter value. Typically in [last_name][date][first_word_of_paper] format for papers. <p>Following is an example of a parameter file.</p> <p></p> <p>Note</p> <p>If you forget to add or insert any needed parameter in the file when you run the code, it shows you this message at the end:</p> <p></p> <p>At this time, you should edit the <code>[resources_dir]/[file_prefix]_parameters_unfinished.csv</code> file that will have been created.</p> <p>This file will include the parameters which were not inserted in the file with EMPTY_MUST_BE_FILLED value and data_reference entries. You should add the parameter value and a reference in the file. Subsequently, delete the last part of the file's name (\u201cunfinished\u201d) and rerun the code to solve the issue.</p>"},{"location":"create-model/#modules-and-definition-of-a-new-module","title":"Modules and definition of a new module","text":"<p>In the <code>[project_dir]/src/generators/resources</code> directory, there are several CellML files which contain the modules that can be coupled together in your model. The <code>module_config.json file</code> defines the connection ports and variables of each cellml module.</p> <p></p> <p>The <code>base_script.cellml</code> is the template of the main cellml file that gets generated (shown below). It uses the <code>units.cellml</code> in the main generated code to add all types of units. Also, <code>module_config.json</code> is the main file used in autogeneration to know how to couple the cellml files in the arrangement defined by the vessel_array file.</p> <p></p> <p>If you want to create a new module, you must add the related JSON data in the <code>module_config.json</code> and link to the file where the cellml file is contained, e.g. <code>BG_modules.cellml</code> or another cellml file in <code>[project_dir]/src/generators/resources/</code>.</p> <p>As shown in the below figure, there are three different parts for each module. The primary specification includes vessel_type, boundary condition type, and module_file, then the ports and their types, and finally, variables and constants.</p> <p></p> <p>Following is one of the modules in the <code>BG_modules</code> file. The main body of a specific module contains variables declaration, constitutive parameters, and state variables. Then, you should write the constitutive relations and eventually, ODE equations.</p> <p></p>"},{"location":"create-model/#example-of-creating-a-new-module","title":"Example of creating a new module","text":"<p>This section shows a simple example to create a new module, which you can find in the JSON file.</p> <p>We want to define a new vessel type with the name of \"arterial\" with boundary condition type \"vp\". Additionally, we want to use the \"vp_type\" module, whose cellml code is shown in the above figure. Also, the module is located in the <code>BG_modules.cellml</code> file.</p> <p>Vessel_type, BC_type, module_format, module_file location, module_type and other related information are added to the <code>module_config.json</code> file, as shown below. We can now use this vessel_type in the vessel_array file in <code>[resources_dir]</code> to add the module with specified inputs, outputs and parameters. In the ports, you should add the \"vessel_port\" type for connecting to the other parts. Additionally, each module can be used in many vessel_types.</p> <p></p> <p>The entries in the <code>module_config.json</code> file are detailed as follows:</p> <ul> <li>vessel_type: This will be the \"vessel_type\" entry in the vessel_array file</li> <li>BC_type: This will be the \"BC_type\" entry in the vessel_array file</li> <li>module_format: Currently only cellml is supported but in the future, cpp modules and others will be allowed.</li> <li>module_file: The file within <code>[project_dir]/src/generators/resources/</code> that contains the cellml module that this config entry links to.</li> <li>module_type: The name of the module/computational_environment within the module cellml file.</li> <li>entrance_ports: Specification of the port types that this module can take if it is connected as an \"out_vessel\" to another module.</li> <li>exit_ports: Specification of the port types that this module can take if it is connected as an \"inp_vessel\" to another module.</li> <li>port_types: The name of the type of port. If two vessels are connected vessel_a to vessel_b, and vessel_a has an exit_port with the same port_type as an entrance_port of vessel_b, then a connection will be made. </li> <li>variables: These are the variables within the module that will be connected to the variables in the corresponding port of the connected vessel/module.</li> <li> <p>variables_and_units: This specifies all of the constants and the accesible variables of the cellml module. The entries are:</p> <ul> <li>[0] variable name: corresponding to the name in the cellml file</li> <li>[1] variable unit: corresponsing to the unit specification in <code>units.cellml</code></li> <li>[2] access or no_access: whether the variable can be accessed within the cellml simulation. This should always be \"access\" for accessibility, unless you want to decrease memory usage.</li> <li>[3] parameter type: can be constant, global_constant, or variable.</li> </ul> <p>Note</p> <p>All constants are required to be entered in the <code>[resources_dir]/[file_prefix]_parameters.csv</code> file with the following naming convention: [variable_name]_[vessel_name].</p> <p>All global_constants are required to be entered in the <code>[resources_dir]/[file_prefix]_parameters.csv</code> file as just [variable_name].</p> </li> </ul>"},{"location":"example-3compartment-model/","title":"Example: 3Compartment Model","text":"<p>A schematic view of this model is shown above with details of boundary conditions, parts' names, vein connection, and direction of blood flow through. The heart is modeled as a simple valve module in this example. According to this schematic, the vessel and parameters files are designed as shown in below figures.</p> <p></p> <p></p> <p>In the <code>vessel_array</code> file, there are five columns: name, BC_type, vessel_type, inp_vessels, and out_vessels. </p> <p>name is the user-chosen module's name, for example \"heart\" or \"aortic_root\". </p> <p>BC_type is the boundary condition type for circulatory system vessels. The BC of vessel modules should be one of the \"vv\", \"vp\", \"pv\", and \"pp\" types. The first letter defines input pressure (p) or flow (v) boundary condition, the second letter defines output pressure (p) or flow (v) boundary condition. For example the pulmonary vein (pvn) in the above example has a vp BC type, meaning it has input flow and output pressure boundary conditions.</p> <p>Info</p> <p>A vessel with \"output flow\" BC must be connected to a vessel with \"input pressure\" BC and vice versa. E.g. a \"vp\" can only have either a \"vv\" or \"vp\" vessel as ouputs. This is checked in the software, and will throw an error if there are incorrect BC connections.</p> <p>The vessel_type and BC_type must match a module with the same vessel_type and BC_type in the modules_config.json defined at <code>[project_dir]/src/generators/resources/</code>. </p> <p>This file is the config file which defines the variables of a module and the connection ports that allows linking between modules, each module links to a cellml module. For more information, refer Creating a new model section.</p> <p>inp_vessels and out_vessels are the inputs and outputs of each module, respectively. Some modules have multiple inputs and outputs, like split_type vessels that split from one to two vessels.</p> <p>Note</p> <p>The order of input and output vessels is important for the heart module. The order must be:</p> <p>inp_vessels:</p> <ol> <li>inferior vena cava</li> <li>superior vena cava</li> <li>pulmonary vein</li> </ol> <p>out_vessels: </p> <ol> <li>aorta</li> <li>pulmonary artery</li> </ol> <p>A simple two-vessel pulmonary system will be used if the pulmonary vessels are not included.</p> <p>Tip</p> <p>Currently, the terminal vessels should only have a BC_type starting with \"pp\".</p> <p>Results:</p> <p>In the below figure, three different variables are plotted versus time. The step size was adjusted to 0.01 seconds. These variables are the \"Aortic_root flow rate\", \"pvn flow rate\", and the \"volume of the heart\", respectively. </p> <p>This is the model before doing model calibration. See section Parameter Identification for info on the parameter identification.</p> <p></p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#initialising-and-startup","title":"Initialising and Startup","text":"<p>The project must be run on a Linux operating system.</p> <p>Tip</p> <p>If you're on Windows, you can install a virtual Linux machine. One of these virtual linux machines is VirtualBox Oracle, which can be downloaded from here.</p> <p>Also, you can download the latest version of Ubuntu using this link.</p> <p>Info</p> <p>Running on Windows is in development. It can work with some caveats. See Running on Windows for more information.</p> <p>1. Install OpenCOR</p> <p>Download and install OpenCOR software from this link.</p> <p>2. OpenCOR Tutorial</p> <p>Download the OpenCOR tutorial, which is a comprehensive tutorial including many examples: OpenCOR Tutorial.</p> <p>3. Clone the project</p> <p>Clone the project from the GitHub repository.</p> <p>Note</p> <p>If you have not worked with git and GitHub, firstly download and install git, and then open the terminal and navigate to a directory where you want the repository to be. Then write these commands to clone the project on your pc:</p> <ul> <li> <p><code>git clone https://github.com/FinbarArgus/circulatory_autogen</code></p> </li> <li> <p><code>git remote add origin https://github.com/FinbarArgus/circulatory_autogen</code></p> </li> </ul> <p>If you want to develop the code, then create a fork of the above repo in GitHub, then do the following lines instead of the above:</p> <ul> <li> <p><code>git clone https://github.com/&lt;YourUsername&gt;/circulatory_autogen</code></p> </li> <li> <p><code>git remote add origin https://github.com/&lt;YourUsername&gt;/circulatory_autogen</code></p> </li> <li> <p><code>git remote add upstream https://github.com/FinbarArgus/circulatory_autogen</code></p> </li> </ul>"},{"location":"getting-started/#directory-definition","title":"Directory Definition","text":"<p>In this tutorial, we use one particular directory for our project, but it can be different on every computer. So the base directory is defined as main_dir in all parts. For example, on our computer, this directory is as below:</p> <p><code>main_dir: Home/\u2026/Desktop/</code></p> <p>The project directory project_dir is the directory where the GitHub Circulatory_autogen project is cloned to our computer. For example, the directory may be:</p> <p><code>[project_dir]: Home/\u2026/Desktop/Project/Circulatory_autogen</code></p> <p>Also, OpenCOR files directory is needed for opening the project and installing python and pythonshell, and we show with OpenCOR_dir, which is below on our pc:</p> <p><code>OpenCOR_dir: Home/\u2026/Desktop/OpenCOR</code></p> <p>Info</p> <p>If running on the ABI HPC, you can use the OpenCOR at the path: /hpc/farg967/OpenCOR-2022-05-23-Linux/. </p> <p>Ignore the below installation steps.</p>"},{"location":"getting-started/#python-and-libraries-installation","title":"Python and Libraries Installation","text":"<p>To run openCOR, you need to use the Python version with openCOR. </p> <p>To install required python packages, navigate to <code>[OpenCOR_dir]/python/bin</code> directory and run the below command.</p> <pre><code>./python -m pip install &lt;packagename&gt;\n</code></pre> <p>Tip</p> <p>In versions of OpenCOR: 0.8 and onwards you can navigate to <code>[OpenCOR_dir]</code> and run the below command.</p> <pre><code>pip install &lt;packagename&gt;\n</code></pre> <p>This is more robust and doesn't have SSL errors as below.</p> <p>Note</p> <p>Required packages for autogeneration: pandas pyyaml libcellml rdflib</p> <p>Required packages for parameter identification: mpi4py sympy</p> <p>Required packages for mcmc bayesian identification: emcee corner schwimmbad tqdm statsmodels</p> <p>Required for some utilities: ruamel.yaml</p> <p>Warning</p> <p>if you get an SSL error you must do the following before the pip install:</p> <pre><code>cd [OpenCOR_dir]/python/bin\nexport LD_LIBRARY_PATH=[OpenCOR_dir]/lib\n</code></pre> <p>This would let the system know where to look for libcrypto.so.3 when loading the ssl module.</p> <p>Warning</p> <p>Intalling mpi4py requires mpi to be available. Therefore, the following lines may be required to install the mpi software on your computer.</p> LinuxMac <pre><code>sudo apt install libopenmpi-dev\nsudo apt install libffi7\n</code></pre> <pre><code>brew install openmpi\n</code></pre>"},{"location":"getting-started/#running-on-windows","title":"Running on Windows","text":"<p>You have to run the scripts in <code>src/scripts</code> explicitly since you cannot use the .sh files to run scripts. </p> <p>E.g. For running param id, navigate to to <code>C:\\path\\to\\opencor\\dir</code> and run the below command.</p> <pre><code>.\\pythonshell.bat C:\\path\\to\\circulatory\\autogen\\src\\scripts\\param_id_run_script.py\n</code></pre> <p>To be able to importing mpi4py, you may have to do the following:</p> <ol> <li> <p>Download MS MPI, install both .mis and SDK.</p> </li> <li> <p>Set up environmental variables.</p> <p>Tip</p> <p>Open <code>Control Panel</code> and select <code>Advanced System Settings</code>. Then select <code>Environmental Variables</code> and add the following.</p> <pre><code>C:\\Program Files\\Microsoft MPI\\\nC:\\Program Files (x86)\\Microsoft SDKs\\MPI\\\n</code></pre> </li> </ol> <p>Changes to be made</p> <p>Currently vessels is used interchangeabley with modules. This will be changed to use modules in all instances, as the project now allows all types of modules, not just vessels.</p> <p>The connections between terminals and the venous system is hardcoded, as a terminal_venous_connection has to be made to sum up the flows and get an avergae concentration. This needs to be improved.</p>"},{"location":"model-generation-simulation/","title":"Model Generation and Simulation","text":""},{"location":"model-generation-simulation/#software-outline","title":"Software Outline","text":"<p>The Circulatory_autogen project contains five folders as presented below:       </p> <ul> <li>funcs_user: TODO</li> <li>module_config_user: TODO</li> <li>resources: Contains the config csv files that the user defines to construct the model that will be generated and to prescribe it's parameters.</li> <li>src: Containts the source code for autogeneration, parameter id, and other utilities.</li> <li>user_run_files: Includes essential run files for the user and the user_inputs.yaml file, which is the main config file for the run settings.</li> </ul> <p>Following folders will be generated after running model autogeneration and parameter identification.</p> <ul> <li>generated_models: Includes the generated code for the models that have been automatically generated. It also contains the generated models with parameters that have been fit with the parameter identification code. These models can be run in OpenCOR or through OpenCOR's version of Python.</li> <li>param_id_output: Includes all of the outputs from the parameter identification simulations, including predicted parameter values, minimum costs, standard deviations of parameters (if doing MCMC) and plots of the fitting results and parameter distributions.</li> </ul>"},{"location":"model-generation-simulation/#model-generation","title":"Model Generation","text":"<p>This section shows how to generate your desired model. There are several examples to show the generality of the circulatory_autogen software.</p> <p>Following are the steps for model autogeneration.</p> <ol> <li> <p>Create the vessel_array and parameters files in CSV format for the intended model. Proper names of vessel and parameters files are [model name]_vessel_array.csv and [model name]_parameters.csv, respectively. </p> <p>Those files should be added to the <code>[project_dir]/resources</code> directory. If you want to define your own resources_dir, you can add a <code>resources_dir:</code> entry in <code>[project_dir]/user_run_files/user_inputs.yaml</code> which will override the default <code>[project_dir]/resources</code> directory.</p> <p>Info</p> <p>If the name of your model is 3compartment, the mentioned files are:</p> <ul> <li><code>3compartment_vessel_array.csv</code></li> <li><code>3compartment_parameters.csv</code></li> </ul> <p>Note</p> <p>You can refer the section Creating a new model for more details on creating vessel_array and parameters files.</p> </li> <li> <p>Go to the <code>[project_dir]/user_run_files</code> and open the <code>user_inputs.yaml</code> to edit. You can use gedit, nano, or your editor of choice (eg: vim) to edit the file. <code>file_prefix</code> should be the name of your model. Subsequently, <code>input_param_file</code> should be equal to <code>[model_name]_parameters.csv</code> as shown below.</p> <p></p> </li> <li> <p>Open <code>[project_dir]/user_run_files/opencor_pythonshell_path.sh</code> file and change the <code>opencor_pythonshell_path</code> to the directory of pythonshell in the openCOR folder similar to: <code>&lt;OpenCOR_dir&gt;/pythonshell</code>.</p> <p></p> </li> <li> <p>To run the autogeneration, navigate to the <code>user_run_files</code> directory and run the below command.</p> <pre><code>./run_autogeneration.sh\n</code></pre> <p>As shown below, this will create CellML files for the generated model and test that the simulation runs. Consequently, If there are no errors, it shows the \"Model generation has been successful.\" message at the end.</p> <p></p> </li> <li> <p>Generated CellML files are located in the <code>[generated_models_dir]/[file_prefix]</code> directory. (The generated_models_dir defaults to <code>[project_dir]/generated_models</code> unless you set generated_models_dir in <code>[project_dir/user_run_files/user_inputs.yaml</code>). </p> <p>Four CellML files, and a CSV file will be generated. The CSV file includes the model parameters and the four CellML files contain the modules, parameters, units and constants, and main model.</p> <p></p> <p>Info</p> <p>For a typical autogeneration, the CSV file will be the same as the parameters.csv file in <code>[project_dir]/resources</code> directory. However, when the parameter identification is run, it will contain the identified parameter values.</p> </li> </ol> <p>Note</p> <p>There is a test for the autogeneration running. To run the test, navigate to <code>user_run_files</code> and run the below command.</p> <pre><code>./run_test_autogeneration.sh\n</code></pre>"},{"location":"model-generation-simulation/#model-simulation","title":"Model Simulation","text":"<p>Once you have generated the models, open OpenCOR and open the generated <code>[file_prefix].cellml</code>, which is the main CellML file. This file calls to the <code>[file_prefix]_modules.cellml</code>, <code>[file_prefix]_parameters.cellml</code> and <code>[file_prefix]_units.cellml</code> files.</p> <p>When it is opened, click on the Simulation tab (highlighted with a yellow box in the below image). If there is no error, OpenCOR shows you a new page where models can be simulated. (If there is an error specific to the cellml code then it will be shown here.)</p> <p></p> <p>Several individual parts on this page are:</p> <ul> <li>Simulation settings</li> <li>ODE solver settings</li> <li>Parameters and variables</li> <li>Run control</li> <li>Run diagnostics</li> <li>Graphs and results</li> </ul> <p>You should set the simulation's starting, ending, and data output step size. Also, if you have a stiff problem you may need to set the maximum_time_step to a small value.</p> <p>ODE solver settings contains many settings related to the solver such as maximum step size, iteration method, absolute and relative tolerance, name of solver, etc. (shown in the blue box in the above image.)</p> <p>The parameters and variables section shows all constant and variable parameters that are used in the model (See section Creating a new model for more information on setting up parameters). You can plot variables by right-clicking each parameter you want for the y-axis and then choosing the x-axis variable (eg: time). </p> <p>The run control is on the top left section, as shown in the purple color box in the image. Click on the triangle button to run. For further control, see the OpenCOR Tutorial.</p> <p>The results will be shown after running the model. These results include run-time, settings, and other related parameters, as shown in the yellow box at the bottom of the image.</p>"},{"location":"parameter-identification/","title":"Parameter Identification","text":"<p>The parameter identification part of Circulatory_Autogen is designed to allow calibration of a model to experimental or clinical data. It implements an optimisation method to find the best fit parameters that give a minimal (local minima) error difference between the model output and the ground truth observables (experimental or clinical data or user specified). The creation of below two configuration files is necessary: </p> <ul> <li>params_for_id</li> <li>param id observables</li> </ul> <p>Those files should be added to the <code>[project_dir]/resources</code> directory. Proper names of the files are [file_prefix]_params_for_id.csv and [file_prefix]_obs_data.json, respectively.</p>"},{"location":"parameter-identification/#creating-params_for_id-file","title":"Creating params_for_id file","text":"<p>This file defines which parameters (constants and initial_states) within your model that you will vary in the parameter id process and their allowed ranges (prior distribution). Following is an example of the <code>params_for_id.csv</code> file.</p> <p></p> <p>The entries in the file are detailed as follows:</p> <ul> <li>vessel_name: the name of the vessel/module the parameter is in</li> <li>param_name: the name of the parameter in the cellml module (not including the \"vessel_name\" suffix that is included in the <code>[file_prefix]_parameters.csv</code> file).</li> <li>param_type: \"state\" or \"const\"; whether the parameter is the initial value of a state or a const. </li> <li>min: The minimimum of the range of possible values (min of the uniform distribution).</li> <li>max: The maximum of the range of possible values (max of the uniform distribution).</li> <li>name_for_plotting: The name (latex format) that will be used when automatically potting comparisons with observables and predictions.</li> </ul> <p>Note</p> <p>param_type will be deprecated. All should be \"const\". Initial values that need to identified should be defined as constants within the cellml module.</p> <p>Info</p> <p>In the future we plan on including other types of priors rather than just uniform.</p>"},{"location":"parameter-identification/#creating-param-id-observables-file","title":"Creating param id observables file","text":"<p>This file defines the ground truth observables that will be used in the cost function for the parameter id optimisation algorithm. It also defines the measurement standard deviation, and weighting for each observable.</p> <p>File path of the obs_data.json file should be defined as param_id_obs_path in <code>[project_dir]/user_run_files/user_inputs.yaml</code>.</p> <p>Examples of <code>obs_data.json</code> file are shown in below figures for constant, series, and frequency data types, respectively. </p> <p> </p> <p>The entries in the <code>obs_data.json</code> file are:</p> <ul> <li>variable: <code>[vessel_name]/[variable_name]</code>, where variable name is the variable name in the cellml module and <code>module_config.json</code> file.</li> <li>data_type: The format of the data. This can be \"constant\", \"series\", or \"frequency\" as shown above.</li> <li>unit: The unit which should be the same as the unit in the variable in the model.</li> <li>name_for_plotting: The name that will be in the automated plots comparing observable data to model output. (latex format)</li> <li>weight: The weighting to put on this observables entry in the cost function. Default should be 1.0</li> <li>std: The standard deviation which is used in the cost function. The cost function is the relative absolute error (AE) or mean squared error (MRE), each normalised by the std.</li> <li>obs_type: The operation that will be done on the model output series before it being applied to calculate the cost function, (min, max, mean, etc). </li> <li>value: The value of the ground truth, either a scalar for constant data_type, or a list of values for series or frequency data_types.</li> <li>sample_rate: not needed or set to \"null\" for constant and frequency data_types. It defines the sample rate of the observable series values.</li> <li>operation: This will make obs_type obsolete. This defines the operation that will be done on the operands/variable. The possible operations to be done on model outputs are defined in <code>[project_dir]/src/param_id/operation_funcs.py</code> and in <code>[project_dir]/operation_funcs_user/operation_funcs_user.py</code> for user defined operations.</li> <li>operands: The above defined \"operation\" can take in multiple variables. If operands is defined, then the \"variable\" entry will be a placeholder name for the calculated variable and the operands will define the model variables that are used to calculate the final variable that will be compared to the observable value entry/s.</li> </ul> <p>Warning</p> <p>obs_type: This has been deprecated in favor of the operation entry.</p>"},{"location":"parameter-identification/#parameter-identification-settings","title":"Parameter Identification Settings","text":"<p>To run the parameter identification we need to set a few entries in the <code>[project_dir]/user_run_files/user_inputs.yaml file</code>:</p> <ul> <li>param_id_method: this defins the optimisation method we use. Currently this can only be genetic_algorithm, but more methods are being implemented. Eventually we aim to use CVODES to allow for gradient based optimisation methods.</li> <li>pre_time: this is the amount of time the simulation is run to get to steady state before comparing to the observables from <code>obs_data.json</code></li> <li>sim_time: The amount of time used to compare simulation output and observable data. This should be equal to the length of a series observable entry divided by the \"sample_rate\". If not, only up to the minimum length of observable data and modelled data will be compared. </li> <li>maximum_step: The maximum time step for the CVODE solver</li> <li>dt: The output time step (This hasn't been tested well for anything but 0.01 s currently)</li> <li>param_id_obs_path: the path to the <code>obs_data.json</code> file described above.</li> <li>ga_options:<ul> <li>cost_type: \"AE\" or \"MSE\" for absolute error or mean squared error.</li> <li>num_calls_to_function: How many forward simulations of pre_time+sim_time will be run in the optimisation algorithm.</li> </ul> </li> </ul>"},{"location":"parameter-identification/#running-parameter-identification","title":"Running parameter identification","text":"<p>After creating the params_for_id file and the param id observables file, and configuring the above settings, run the parameter identification using the below command.</p> <pre><code>./run_param_id.sh\n</code></pre> <p>Following a successful parameter id process, the model with updated parameters can be generated with:</p> <pre><code>./run_autogeneration_with_id_params.sh\n</code></pre> <p>Plots can be run with:</p> <pre><code>./plot_param_id.sh\n</code></pre> <p>The generated models will be saved in <code>generated_models/</code> directory and plots will be saved in <code>param_id_outputs/</code> directory.</p>"}]}